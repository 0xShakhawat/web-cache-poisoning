# Exploiting cache implementation flaws

In our previous labs, you learned how to exploit web cache poisoning vulnerabilities by manipulating typical unkeyed inputs, such as HTTP headers and cookies. While this approach is effective, it only scratches the surface of what is possible with web cache poisoning.

In this section, we'll demonstrate how you can access a much greater attack surface for web cache poisoning by exploiting quirks in specific implementations of caching systems. In particular, we'll look at why flaws in how cache keys are generated can sometimes leave websites vulnerable to cache poisoning via separate vulnerabilities that are traditionally considered unexploitable. We'll also show how you can take classic techniques even further to potentially poison application-level caches, often with devastating results.

These techniques were first documented by our Director of Research, James Kettle, for his presentation **"Web Cache Entanglement: Novel Pathways to Poisoning"** at BlackHat USA 2020. If you're interested in seeing how he was able to discover and exploit these vulnerabilities in the wild, you can access a recording of this presentation, and the accompanying whitepaper, from our research page:

> **Research**  
> [Web Cache Entanglement: Novel Pathways to Poisoning](https://portswigger.net/research/web-cache-entanglement)

## Cache key flaws

Generally speaking, websites take most of their input from the URL path and the query string. As a result, this is a well-trodden attack surface for various hacking techniques. However, as the request line is usually part of the cache key, these inputs have traditionally not been considered suitable for cache poisoning. Any payload injected via keyed inputs would act as a cache buster, meaning your poisoned cache entry would almost certainly never be served to any other users.

On closer inspection, however, the behavior of individual caching systems is not always as you would expect. In practice, many websites and CDNs perform various transformations on keyed components when they are saved in the cache key. This can include:

- Excluding the query string
- Filtering out specific query parameters
- Normalizing input in keyed components

These transformations may introduce a few unexpected quirks. These are primarily based around discrepancies between the data that is written to the cache key and the data that is passed into the application code, even though it all stems from the same input. These cache key flaws can be exploited to poison the cache via inputs that may initially appear unusable.

In the case of fully integrated, application-level caches, these quirks can be even more extreme. In fact, internal caches can be so unpredictable that it is sometimes difficult to test them at all without inadvertently poisoning the cache for live users.

## Cache probing methodology

The methodology of probing for cache implementation flaws differs slightly from the classic web cache poisoning methodology. These newer techniques rely on flaws in the specific implementation and configuration of the cache, which may vary dramatically from site to site. This means that you need a deeper understanding of the target cache and its behavior.

In this section, we'll outline the high-level methodology for probing the cache to understand its behavior and identify any potential flaws. Afterwards, we'll provide some more concrete examples of common cache key flaws and how you can exploit them.

### The methodology involves the following steps:

1. [Identify a suitable cache oracle](#identify-a-suitable-cache-oracle)
2. [Probe key handling](#probe-key-handling)
3. [Identify an exploitable gadget](#identify-an-exploitable-gadget)

### Identify a suitable cache oracle

The first step is to identify a suitable "cache oracle" that you can use for testing. A cache oracle is simply a page or endpoint that provides feedback about the cache's behavior. This needs to be cacheable and must indicate in some way whether you received a cached response or a response directly from the server. This feedback could take various forms, such as:

- An HTTP header that explicitly tells you whether you got a cache hit
- Observable changes to dynamic content
- Distinct response times

Ideally, the cache oracle will also reflect the entire URL and at least one query parameter in the response. This will make it easier to notice parsing discrepancies between the cache and the application, which will be useful for constructing different exploits later.

If you can identify that a specific third-party cache is being used, you can also consult the corresponding documentation. This may contain information about how the default cache key is constructed. You might even stumble across some handy tips and tricks, such as features that allow you to see the cache key directly. For example, Akamai-based websites may support the header `Pragma: akamai-x-get-cache-key`, which you can use to display the cache key in the response headers:

```
GET /?param=1 HTTP/1.1
Host: innocent-website.com
Pragma: akamai-x-get-cache-key

HTTP/1.1 200 OK
X-Cache-Key: innocent-website.com/?param=1
```

### Probe key handling

The next step is to investigate whether the cache performs any additional processing of your input when generating the cache key. You are looking for an additional attack surface hidden within seemingly keyed components.

You should specifically look at any transformation that is taking place. Is anything being excluded from a keyed component when it is added to the cache key? Common examples are excluding specific query parameters, or even the entire query string, and removing the port from the `Host` header.

If you're fortunate enough to have direct access to the cache key, you can simply compare the key after injecting different inputs. Otherwise, you can use your understanding of the cache oracle to infer whether you received the correct cached response. For each case that you want to test, you send two similar requests and compare the responses.

Example:

```
GET / HTTP/1.1
Host: vulnerable-website.com

HTTP/1.1 302 Moved Permanently
Location: https://vulnerable-website.com/en
Cache-Status: miss
```

Request with a port:

```
GET / HTTP/1.1
Host: vulnerable-website.com:1337

HTTP/1.1 302 Moved Permanently
Location: https://vulnerable-website.com:1337/en
Cache-Status: miss
```

Then again without the port:

```
GET / HTTP/1.1
Host: vulnerable-website.com

HTTP/1.1 302 Moved Permanently
Location: https://vulnerable-website.com:1337/en
Cache-Status: hit
```

This proves that the port is being excluded from the cache key. Importantly, the full header is still passed into the application code and reflected in the response.

### Identify an exploitable gadget

The final step is to identify a suitable gadget that you can chain with this cache key flaw. This is an important skill because the severity of any web cache poisoning attack is heavily dependent on the gadget you are able to exploit.

These gadgets will often be classic client-side vulnerabilities, such as reflected XSS and open redirects. By combining these with web cache poisoning, you can massively escalate the severity of these attacks, turning a reflected vulnerability into a stored one.

These techniques also enable you to exploit a number of unclassified vulnerabilities that are often dismissed as "unexploitable" and left unpatched.

## Exploiting cache key flaws

Now that you're familiar with the high-level methodology, let's take a look at some typical cache key flaws and how you might exploit them. We'll cover:

- [Unkeyed port](#unkeyed-port)
- [Unkeyed query string](#unkeyed-query-string) `LAB`
- [Unkeyed query parameters](#unkeyed-query-parameters) `LAB`
- [Cache parameter cloaking](#cache-parameter-cloaking) `LAB`
- [Normalized cache keys](#normalized-cache-keys) `LAB`
- [Cache key injection](#cache-key-injection) `LAB`
- [Internal cache poisoning](#poisoning-internal-caches) `LAB`

### Unkeyed port

The `Host` header is often part of the cache key and, as such, initially seems an unlikely candidate for injecting any kind of payload. However, some caching systems will parse the header and exclude the port from the cache key.

This might enable you to construct a denial-of-service attack by simply adding an arbitrary port to the request. All users browsing to the home page would be redirected to a dud port.

This can be escalated further if the website allows a non-numeric port, potentially enabling XSS payload injection.

### Unkeyed query string

Like the `Host` header, the request line is typically keyed. However, one common transformation is to exclude the entire query string.

#### Detecting an unkeyed query string

If the response explicitly tells you whether you got a cache hit or not, this is easy to detect. Otherwise, dynamic pages may appear static.

You can try adding a cache buster to a keyed header instead. For example:

```http
Accept-Encoding: gzip, deflate, cachebuster  
Accept: */*, text/cachebuster  
Cookie: cachebuster=1  
Origin: https://cachebuster.vulnerable-website.com
```

Tools like Param Miner can help automate this testing process.

Also, try path variations like:

- Apache: `GET //`  
- Nginx: `GET /%2F`  
- PHP: `GET /index.php/xyz`  
- .NET: `GET /(A(xyz)/`

These may help detect reflected XSS vulnerabilities hidden by caching.

#### Exploiting an unkeyed query string

Poisoning the cache via an unkeyed query string can turn reflected XSS into stored XSS, causing the payload to be served to all users accessing a normal URL.

> **LAB:**  
> [Web cache poisoning via an unkeyed query string](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-unkeyed-query)

### Unkeyed query parameters

Some websites exclude only specific parameters like `utm_content` from the cache key.

Even though these are unlikely to influence the response, some pages may handle the entire URL in a vulnerable way, allowing arbitrary parameter exploitation.

> **LAB:**  
> [Web cache poisoning via an unkeyed query parameter](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-unkeyed-param)


### Cache parameter cloaking

If the cache excludes a harmless parameter from the cache key, and you can't find any exploitable gadgets based on the full URL, you'd be forgiven for thinking that you've reached a dead end. However, this is actually where things can get interesting.

If you can work out how the cache parses the URL to identify and remove the unwanted parameters, you might find some interesting quirks. Of particular interest are any parsing discrepancies between the cache and the application. This can potentially allow you to sneak arbitrary parameters into the application logic by "cloaking" them in an excluded parameter.

For example, the de facto standard is that a parameter will either be preceded by a question mark (`?`), if it's the first one in the query string, or an ampersand (`&`). Some poorly written parsing algorithms will treat any `?` as the start of a new parameter, regardless of whether it's the first one or not.

Let's assume that the algorithm for excluding parameters from the cache key behaves in this way, but the server's algorithm only accepts the first `?` as a delimiter. Consider the following request:

```
GET /?example=123?excluded_param=bad-stuff-here
```

In this case, the cache would identify two parameters and exclude the second one from the cache key. However, the server doesn't accept the second `?` as a delimiter and instead only sees one parameter, `example`, whose value is the entire rest of the query string, including our payload. If the value of `example` is passed into a useful gadget, we have successfully injected our payload without affecting the cache key.

#### Exploiting parameter parsing quirks

Similar parameter cloaking issues can arise in the opposite scenario, where the back-end identifies distinct parameters that the cache does not. The Ruby on Rails framework, for example, interprets both ampersands (`&`) and semicolons (`;`) as delimiters. When used in conjunction with a cache that does not allow this, you can potentially exploit another quirk to override the value of a keyed parameter in the application logic.

Consider the following request:

```
GET /?keyed_param=abc&excluded_param=123;keyed_param=bad-stuff-here
```

As the names suggest, `keyed_param` is included in the cache key, but `excluded_param` is not. Many caches will only interpret this as two parameters, delimited by the ampersand:

1. `keyed_param=abc`
2. `excluded_param=123;keyed_param=bad-stuff-here`

Once the parsing algorithm removes the `excluded_param`, the cache key will only contain `keyed_param=abc`. On the back-end, however, Ruby on Rails sees the semicolon and splits the query string into three separate parameters:

1. `keyed_param=abc`
2. `excluded_param=123`
3. `keyed_param=bad-stuff-here`

But now there is a duplicate `keyed_param`. This is where the second quirk comes into play. If there are duplicate parameters, each with different values, Ruby on Rails gives precedence to the final occurrence. The end result is that the cache key contains an innocent, expected parameter value, allowing the cached response to be served as normal to other users. On the back-end, however, the same parameter has a completely different value, which is our injected payload. It is this second value that will be passed into the gadget and reflected in the poisoned response.

This exploit can be especially powerful if it gives you control over a function that will be executed. For example, if a website is using JSONP to make a cross-domain request, this will often contain a `callback` parameter to execute a given function on the returned data:

```
GET /jsonp?callback=innocentFunction
```

In this case, you could use these techniques to override the expected callback function and execute arbitrary JavaScript instead.

> **Lab**: [Parameter cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking) (Practitioner)  

---

#### Exploiting fat GET support

In select cases, the HTTP method may not be keyed. This might allow you to poison the cache with a `POST` request containing a malicious payload in the body. Your payload would then even be served in response to users' `GET` requests.

Although this scenario is pretty rare, you can sometimes achieve a similar effect by simply adding a body to a `GET` request to create a "fat" `GET` request:

```
GET /?param=innocent HTTP/1.1
…
param=bad-stuff-here
```

In this case, the cache key would be based on the request line, but the server-side value of the parameter would be taken from the body.

You can sometimes encourage "fat GET" handling by overriding the HTTP method, for example:

```
GET /?param=innocent HTTP/1.1
Host: innocent-website.com
X-HTTP-Method-Override: POST
…
param=bad-stuff-here
```

As long as the `X-HTTP-Method-Override` header is unkeyed, you could submit a pseudo-`POST` request while preserving a `GET` cache key derived from the request line.

> **Lab**: [Web cache poisoning via a fat GET request](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get) (Practitioner)  

---

#### Exploiting dynamic content in resource imports

Imported resource files are typically static but some reflect input from the query string. This is mostly considered harmless, but by combining this with web cache poisoning, you can occasionally inject content into the resource file.

For example, consider a page that reflects the current query string in an import statement:

```
GET /style.css?excluded_param=123);@import… HTTP/1.1

HTTP/1.1 200 OK
…
@import url(/site/home/index.part1.8a6715a2.css?excluded_param=123);@import…
```

You could exploit this behavior to inject malicious CSS that exfiltrates sensitive information from any pages that import `/style.css`.

If the page importing the CSS file doesn't specify a `doctype`, you can maybe even exploit static CSS files. You can poison static CSS files by triggering a server error that reflects the excluded query parameter:

```
GET /style.css?excluded_param=alert(1)%0A{}*{color:red;} HTTP/1.1

HTTP/1.1 200 OK
Content-Type: text/html
…
This request was blocked due to…alert(1){}*{color:red;}
```

---

### Normalized cache keys

Any normalization applied to the cache key can also introduce exploitable behavior. For example, modern browsers typically URL-encode characters when sending requests. If a cache normalizes input, both of the following requests might have the same key:

```
GET /example?param="><test>
GET /example?param=%22%3e%3ctest%3e
```

If you send a malicious request using Burp Repeater, you can poison the cache with an unencoded XSS payload. When the victim visits the malicious URL, the normalized URL will match the cached response, and the payload will execute client-side.

> **Lab**: [URL normalization](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-normalization) (Practitioner)  

---

### Cache key injection

You might discover a client-side vulnerability in a keyed header. If the cache doesn’t properly escape delimiters in cache key components, you can exploit this.

Example:

```
GET /path?param=123 HTTP/1.1
Origin: '-alert(1)-'__

HTTP/1.1 200 OK
X-Cache-Key: /path?param=123__Origin='-alert(1)-'__

<script>…'-alert(1)-'…</script>
```

Then lure a victim to visit this:

```
GET /path?param=123__Origin='-alert(1)-'__ HTTP/1.1

HTTP/1.1 200 OK
X-Cache-Key: /path?param=123__Origin='-alert(1)-'__
X-Cache: hit

<script>…'-alert(1)-'…</script>
```

> **Lab**: [Cache key injection](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-cache-key-injection) (Expert)  

---

## Poisoning internal caches

Some applications implement internal caches that cache response fragments rather than full responses. These fragments may not use cache keys at all. Poisoning such a fragment can affect every user on every page that reuses it.

This often only requires manipulating headers like `Host`.

---

### How to identify internal caches

Internal caches are harder to detect. Look for responses that:

- Reflect both new and old input.
- Show your input on pages where you didn’t inject anything.
- Exhibit unusual caching behavior.

---

### Testing internal caches safely

Traditional cache busters don't help here. To minimize risk:

- Only poison with a domain you control.
- Avoid using arbitrary domains like `evil-user.net`.
- Be mindful of payload effects before sending.

> **Lab**: [Internal cache poisoning](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-internal) (Expert)  



